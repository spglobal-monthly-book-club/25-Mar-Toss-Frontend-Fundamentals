# Frontend Fundamentals

> [Frontend Fundamentals - 변경하기 쉬운 프론트엔드 코드를 위한 지침서](https://frontend-fundamentals.com)를 읽으며

좋은 프론트엔드 코드는 **변경하기 쉬운** 코드다.

새로운 요구사항을 구현하고자 할 때, 기존 코드를 수정하고 배포하기 수월한 코드가 좋은 코드인 것이다.

코드가 변경하기 쉬운지는 4가지 기준으로 판단할 수 있다.

## 1. 가독성

- 맥락 줄이기

  - 같이 실행되지 않는 코드 분리하기 : 분기가 많은 코드(컴포넌트)는 코드 이해를 어렵게 한다.
 
  - 구현 상세 추상화하기 : 추상화는 코드 맥락을 줄여 코드 이해를 돕는다.
 
    💡 Wrapper 컴포넌트 사용하기 : Headless 컴포넌트를 의미하는 듯하다. 요즘 이 패턴을 즐겨 사용한다. (sooplive-web `/domains/player/common/components/headless`, `/domains/player/live/components/headless` 참고)

    💡 HOC(Higher-Order Component) 사용하기 : 사실 위 방법이랑 같다. 다만, 컴포넌트 형식이 아닌 함수 형식으로 사용하여 UI 요소가 아님을 더 어필할 수 있을거 같다.

    💡 이벤트 핸들러를 이벤트 트리거 요소와 가까이 두고, 이벤트 핸들러 로직이 별도의 맥락을 만들어낸다면 새로운 컴포넌트로 분리하자.

  - 로직 종류에 따라 합쳐진 함수 쪼개기 : 함수나 컴포넌트, Hook이 가진 책임이 늘어나면 맥락이 점점 늘어나 이해하기 힘들고 수정하기 어려워진다.
 
- 이름 붙이기

  - 복잡한 조건에 이름 붙이기 : 복잡한 조건식에는 뜻하는 바를 한 눈에 파악하기 쉬운 이름을 붙이자.

  - 매직 넘버에 이름 붙이기 : 매직 넘버에 이름을 붙여서 코드를 읽는 사람에게 의도를 전하자.

- 위에서 아래로 읽히게 하기

  - 시점 이동 줄이기 : 코드를 위에서 아래로, 하나의 함수나 파일에서 읽을 수 있도록 코드를 작성하면, 읽는 사람이 동작을 빠르게 파악할 수 있게 된다.
 
  - 삼항 연산자 단순하게 하기 : 삼항 연산자를 복잡하게 사용하면 조건의 구조가 명확하게 보이지 않아 코드를 읽기 어렵게 한다. 복잡한 삼항 연산자는 `if` 문으로 대체하자.

## 2. 예측 가능성

- 이름 겹치지 않게 관리하기 : 이름을 명확하게 정의하여 동작을 오해할 수 있는 가능성을 줄이자.

- 같은 종류의 함수는 반환 타입 통일하기 : API 호출과 관련된 Hook들처럼 같은 종류의 함수나 Hook이 서로 다른 반환 타입을 가지면 코드의 일관성이 떨어져서, 같이 일하는 동료들이 코드를 읽는 데에 헷갈릴 수 있다.

- 숨은 로직 드러내기 : 함수나 컴포넌트의 이름, 파라미터, 반환 값에 드러나지 않는 숨은 로직이 있다면, 함께 협업하는 동료들이 동작을 예측하는 데에 어려움을 겪을 수 있다.

  - sooplive-web `useLiveChannelIn`, `useLiveStatus` 등의 Hook이 해당 문제를 야기하는 예시가 되겠다.

  - 이를 인지하고 최근에 `useLiveMain`, `useHlsjsAdapter` 등 Hook들을 Headless 컴포넌트로 전환하거나 내부 `useEffect` 로직을 제거하고 메서드를 리턴하는 등 리팩토링을 진행하여 숨겨진 로직을 컴포넌트에서 드러내도록 개선했다.

## 3. 응집도

- 함께 수정되는 파일을 같은 디렉토리에 두기 : 함께 수정되는 소스 파일을 하나의 디렉토리에 배치하면 코드의 의존 관계를 명확하게 드러낼 수 있다. ('켄트 벡의 Tidy First?' 에서도 언급된 내용)

  - 이를 인지하고 최근에 `/domains/player` 디렉토리를 생성하여 조금씩 관련 도메인의 코드를 옮기고 있다. (한꺼번에 옮기면 검증해야 할 영역이 많아진다)
 
- 매직 넘버 없애기 : 매직 넘버는 비즈니스 로직일 것이다. (아닐 수도~) 이러한 비즈니스 로직은 변경될 수 있고 다른 비즈니스 영역에 영향을 미칠 수 있다. 따라서 매직 넘버를 상수로 표현해야 영향이 미치는 곳을 같이 변경할 수 있다.

- 폼의 응집도 생각하기 : 응집도를 높이려면 필드 단위와 폼 전체 단위 중 상황에 적합한 방식을 선택해야 한다. 필드 단위로 나누면 재사용성과 독립성이 높아지지만, 폼 전체 단위로 관리하면 일관된 흐름을 유지할 수 있다.

## 4. 결합도

- 책임을 하나씩 관리하기 : 함수나 컴포넌트, Hook에 광범위한 책임을 부여하지 말자. 이로 인해 다른 코드들이 의존하게 될 수 있으며, 코드 수정을 할 때 영향 범위가 급격히 확장될 수 있다.

- 중복 코드 허용하기 : 다소 반복되어 보이는 코드일지 몰라도, 중복 코드를 허용하는 것이 좋은 방향일 수 있다.

  - "처음에는 비슷하게 동작한다고 생각해서 공통화한 코드가, 이후 페이지마다 다른 특이한 요구사항이 생겨서, 점점 복잡해질 수 있어요."

    = sooplive-web 공통 컴포넌트

- Props Drilling 지우기 : Drilling되는 prop이 변경되면 해당 prop을 참조하는 모든 컴포넌트를 수정해야 한다.

  💡 조합(Composition) 패턴 활용 (ex. sooplive-web `SwipeThumbCardList`)

  💡 ContextAPI 활용 (ex. sooplive-web `LiveStreamInfoContext`)

    - `/stream/info` API refetch가 여러 컴포넌트들에 흩어져 있다보니 동일 API 중복 호출이 여러건 발생했었다.
    
      이를 해결하고자 `LiveStreamInfoContext` Context를 만들고 여기서만 `/stream/info` API refetch를 관리하도록 했다.
